import argparse
import sys
from typing import Tuple, List
from dataclasses import dataclass
from os.path import basename, splitext, abspath
import re

try:
    import yaml
except ImportError as e:
    print("ImportError:", e)
    print("Try installing PyYAML with 'pip install pyyaml'")
    sys.exit(1)


def snake_case(s: str) -> str:
    if not re.match(r"^[A-Za-z0-9_\-\s]+$", s):
        raise ValueError(
            f"'{s}' contains invalid characters. "
            + "Only letters, numbers, spaces, hyphens, and underscores are allowed."
        )
    return s.replace("-", "_").replace(" ", "_")


def generate(data, name: str, abs_path: str) -> Tuple[str, str]:
    out = write_field(name, data, [])
    hpp_content = f"""#pragma once
// This file is auto-generated by yamlgenpp
#include <string>
#include <vector>
#include <yaml-cpp/yaml.h>

namespace yamlgenpp {{

{out.hpp_prepend}
}}
extern yamlgenpp::{snake_case(name)}_::dict {snake_case(name)};
"""
    cpp_content = f"""
// This file is auto-generated by yamlgenpp
#include "{name}.hpp"
#include <filesystem>

{out.cpp_prepend}
yamlgenpp::{snake_case(name)}_::dict {snake_case(name)}(YAML::LoadFile("{abs_path}"));
"""
    return hpp_content, cpp_content


@dataclass
class FieldOutput:
    hpp_inline: str = ""
    hpp_prepend: str = ""
    cpp_inline: str = ""
    cpp_body: str = ""
    cpp_prepend: str = ""


def write_field(key: str, value, depth: List[str]) -> FieldOutput:
    out = FieldOutput()

    def literal_node(typestr: str):
        out.hpp_inline = f"  {typestr} {snake_case(key)};\n"
        out.cpp_inline = f'  {snake_case(key)}(node["{key}"].as<{typestr}>()),\n'

    def prepend_dict_node(dictvalue: dict):
        out.hpp_prepend = f"namespace {snake_case(key)}_ {{\n"
        hpp_prepend_current = "struct dict {\n" + "  dict(const YAML::Node &node);\n"
        cpp_prepend_current = (
            "yamlgenpp::"
            + "_::".join(depth + [key])
            + "_::dict"
            + "::dict(const YAML::Node &node):\n"
        )
        cpp_body_current = ""
        for sub_key, sub_value in dictvalue.items():
            sub_out = write_field(str(sub_key), sub_value, depth + [key])
            out.hpp_prepend += sub_out.hpp_prepend
            out.cpp_prepend += sub_out.cpp_prepend
            hpp_prepend_current += sub_out.hpp_inline
            cpp_prepend_current += sub_out.cpp_inline
            cpp_body_current += sub_out.cpp_body
        hpp_prepend_current += "};\n" + "}\n"
        cpp_prepend_current = cpp_prepend_current.rstrip().rstrip(",")
        cpp_prepend_current += "{\n" + cpp_body_current + "}\n"
        out.hpp_prepend += hpp_prepend_current
        out.cpp_prepend += cpp_prepend_current

    if isinstance(value, str):
        literal_node("std::string")
    elif isinstance(value, int):
        literal_node("int")
    elif isinstance(value, float):
        literal_node("double")
    elif isinstance(value, bool):
        literal_node("bool")
    elif isinstance(value, list):
        has_dict = False
        dict_merged = {}
        has_str = False
        has_float = False
        has_bool = False
        for v in value:
            has_str = has_str or isinstance(v, str)
            has_float = has_float or isinstance(v, float) or isinstance(v, int)
            has_bool = has_bool or isinstance(v, bool)
            if isinstance(v, list):
                print(f"Error parsing key '{".".join(depth + [key])}': list of list is not supported yet")
                sys.exit(1)
            if isinstance(v, dict):
                has_dict = True
                for sub_key, sub_value in v.items():
                    dict_merged[sub_key] = sub_value
        if has_dict:
            prepend_dict_node(dict_merged)
        if not value:
            print(f"Warning: key '{".".join(depth + [key])}' is empty list")
        elif int(has_str) + int(has_float) + int(has_bool) + int(has_dict) == 1:
            if has_dict:
                out.hpp_inline = (
                    f"  std::vector<{snake_case(key)}_::dict> {snake_case(key)};\n"
                )
                out.cpp_body = (
                    f'    for(const auto &value: node["{key}"]) '
                    + "key.emplace_back(value);\n"
                )
            elif has_str:
                out.hpp_inline = f"  std::vector<std::string> {snake_case(key)};\n"
                out.cpp_body = (
                    f'    for(const auto &value: node["{key}"]) '
                    + "key.emplace_back(value.as<std::string>());\n"
                )
            elif has_float:
                out.hpp_inline = f"  std::vector<double> {snake_case(key)};\n"
                out.cpp_body = (
                    f'    for(const auto &value: node["{key}"]) '
                    + "key.emplace_back(value.as<double>());\n"
                )
            elif has_bool:
                out.hpp_inline = f"  std::vector<bool> {snake_case(key)};\n"
                out.cpp_body = (
                    f'    for(const auto &value: node["{key}"]) '
                    + "key.emplace_back(value.as<bool>());\n"
                )
        else:
            print(f"Error parsing key '{".".join(depth + [key])}': list of mixed value is not supported yet (TODO)")
            sys.exit(1)
    elif isinstance(value, dict):
        out.hpp_inline = f"  {snake_case(key)}_::dict {snake_case(key)};\n"
        out.cpp_inline = f'  {snake_case(key)}(node["{key}"]),\n'
        prepend_dict_node(value)
    else:
        print(f"Error parsing key '{".".join(depth + [key])}': unsupported type '{type(value)}'")
        sys.exit(1)

    return out


def main():
    parser = argparse.ArgumentParser(description="YAML to C++ struct generator")
    parser.add_argument("files", nargs="*", help="Path to the YAML files.")
    parser.add_argument(
        "-d",
        "--dest",
        type=str,
        default=".",
        help="Destination directory for generated files.",
    )
    args = parser.parse_args()

    if not args.files:
        print("No files provided.")
        sys.exit(1)

    for file in args.files:
        try:
            with open(file, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if data is None:
                    print(f"Warning: The file '{file}' is empty")
                    data = {}
                elif not isinstance(data, dict):
                    print(f"The file '{file}' does not contain a YAML dictionary")
                    sys.exit(1)
                name = basename(splitext(file)[0])
                hpp, cpp = generate(data, name, abspath(file))
                with open(
                    f"{args.dest}/{name}.hpp", "w", encoding="utf-8"
                ) as out_f:
                    out_f.write(hpp)
                with open(
                    f"{args.dest}/{name}.cpp", "w", encoding="utf-8"
                ) as out_f:
                    out_f.write(cpp)
        except FileNotFoundError:
            print(f"The file '{file}' does not exist.")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML file '{file}': {e}")
            sys.exit(1)


if __name__ == "__main__":
    main()
